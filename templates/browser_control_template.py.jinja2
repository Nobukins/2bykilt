import pytest
from playwright.sync_api import expect, Page, Browser
import json
import os
import sys
from pathlib import Path
from datetime import datetime

PROJECT_ROOT = Path(__file__).resolve().parents[1]
if str(PROJECT_ROOT) not in sys.path:
    sys.path.insert(0, str(PROJECT_ROOT))

try:
    from src.runtime.run_context import RunContext
except Exception:  # pragma: no cover - optional dependency for artifact routing
    RunContext = None  # type: ignore[assignment]

OUTPUT_FILE_PARAM = {{ output_file_param }}
OUTPUT_MODE_PARAM = {{ output_mode_param }}

# NOTE:
# pytest-playwright defines core fixtures like `browser` with session scope. If we
# provide custom overriding fixtures (browser_context_args, browser_type_launch_args)
# with a narrower (module/function) scope, pytest raises ScopeMismatch when the
# session-scoped fixture chain attempts to access them. Therefore these MUST be
# session-scoped. See Issue #220 / PR #235.

def _resolve_output_path():
    candidate = OUTPUT_FILE_PARAM.strip() if isinstance(OUTPUT_FILE_PARAM, str) else ""
    base_dir = None
    if RunContext is not None:
        try:
            base_dir = RunContext.get().artifact_dir("browser_control_get_title", ensure=True)
        except Exception as run_exc:  # noqa: BLE001
            print(f"‚ö†Ô∏è Failed to resolve RunContext artifact directory: {run_exc}")
            base_dir = None
    if base_dir is None:
        base_dir = (PROJECT_ROOT / "artifacts" / "runs" / "browser_control_get_title")
        base_dir.mkdir(parents=True, exist_ok=True)

    if candidate:
        path = Path(candidate)
        if not path.is_absolute():
            path = (base_dir / path).resolve()
        else:
            path = path.resolve()
    else:
        path = (base_dir / "get_title_output.txt").resolve()

    path.parent.mkdir(parents=True, exist_ok=True)
    return path


def _determine_output_mode():
    raw = OUTPUT_MODE_PARAM.lower() if isinstance(OUTPUT_MODE_PARAM, str) else str(OUTPUT_MODE_PARAM or "").lower()
    return "w" if raw in {"overwrite", "write", "w"} else "a"


OUTPUT_PATH = _resolve_output_path()
OUTPUT_MODE = _determine_output_mode()


def _append_content_to_file(payload: dict):
    if not OUTPUT_PATH:
        return
    path = Path(OUTPUT_PATH)
    mode = OUTPUT_MODE
    try:
        record = {
            "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "content": payload,
        }
        existing_size = path.stat().st_size if path.exists() else 0
        with open(path, mode, encoding="utf-8") as fh:
            if mode == "a" and existing_size > 0:
                fh.write("\n")
            json.dump(record, fh, ensure_ascii=False, indent=2)
            fh.write("\n")
        print(f"üìù Saved extracted content to {path} (mode={mode})")
    except Exception as write_exc:  # noqa: BLE001
        print(f"‚ö†Ô∏è Failed to write output file {path}: {write_exc}")


@pytest.fixture(scope="session")
def browser_context_args(browser_context_args):
    context_args = {
        **browser_context_args,
        "viewport": {"width": 1280, "height": 720}
    }
    
    # Handle recording from environment variable
    recording_path = os.environ.get('RECORDING_PATH')
    if recording_path:
        context_args["record_video_dir"] = recording_path
        
    return context_args

@pytest.fixture(scope="session")
def browser_type_launch_args(browser_type_launch_args):
    """Configure browser launch arguments based on environment variables"""
    launch_args = {**browser_type_launch_args}
    
    # Check browser type from environment (with override support)
    browser_type = os.environ.get('BYKILT_OVERRIDE_BROWSER_TYPE') or os.environ.get('BYKILT_BROWSER_TYPE', 'chrome')
    print(f"üîç Browser type: {browser_type}")
    
    # Configure headless mode - explicitly set to False unless BYKILT_HEADLESS=true
    headless_env = os.environ.get('BYKILT_HEADLESS', 'false').lower()
    if headless_env == 'true':
        launch_args["headless"] = True
        print(f"üîç Headless mode: ENABLED (via environment variable)")
    else:
        launch_args["headless"] = False
        print(f"üîç Headless mode: DISABLED (UI will be visible)")
    
    # Check for browser executable path from environment
    browser_executable = None
    if browser_type == 'chrome':
        browser_executable = os.environ.get('PLAYWRIGHT_CHROMIUM_EXECUTABLE_PATH')
        if browser_executable:
            launch_args["executable_path"] = browser_executable
            launch_args["channel"] = "chrome"
    elif browser_type == 'edge':
        browser_executable = os.environ.get('PLAYWRIGHT_EDGE_EXECUTABLE_PATH')
        if browser_executable:
            launch_args["executable_path"] = browser_executable
        launch_args["channel"] = "msedge"  # Use Microsoft Edge
    
    if browser_executable and os.path.exists(browser_executable):
        print(f"üéØ Using custom browser: {browser_executable}")
    
    print(f"üîç Browser executable: {browser_executable}")
    
    return launch_args

@pytest.mark.browser_control
def test_browser_control(page: Page):  # noqa: C901
    try:
        # Basic browser control test - verify page is accessible
        assert page is not None
        print("‚úÖ Browser control test passed - page is accessible")
        
        # Test basic page operations
        title = page.title()
        print(f"üìÑ Page title: {title}")
        
        # Process automation flow if defined
        flow = {{ flow }}
        if flow:
            print(f"üîÑ Processing {len(flow)} automation steps...")
            for step in flow:
                action = step.get('action')
                print(f"üîÑ Executing action: {action}")
                
                # Handle URL navigation
                if action in ['navigate', 'command']:
                    url = step['url']
                    print(f"üåê Navigating to: {url}")
                    if 'wait_until' in step:
                        page.goto(url, wait_until=step["wait_until"], timeout=30000)
                    else:
                        page.goto(url, timeout=30000)
                    
                    # Wait for page to be fully loaded (with fallback for dynamic content)
                    try:
                        page.wait_for_load_state("networkidle", timeout=15000)
                        print(f"‚úÖ Page loaded: {page.url}")
                    except Exception as e:
                        print(f"‚ö†Ô∏è Network idle timeout, continuing with page load: {e}")
                        # Fallback: wait for DOM to be ready
                        page.wait_for_load_state("domcontentloaded", timeout=5000)
                        print(f"‚úÖ Page DOM loaded: {page.url}")
                    
                    if step.get('wait_for'):
                        escaped_selector = step['wait_for'].replace('"', '\\"').replace("'", "\\'")
                        expect(page.locator(escaped_selector)).to_be_visible(timeout=10000)
                
                # Handle waiting for selector
                elif action == 'wait_for_selector':
                    selector = step['selector']
                    escaped_selector = selector.replace('"', '\\"').replace("'", "\\'")
                    timeout = step.get('timeout', 10000)
                    print(f"‚è≥ Waiting for selector: {selector}")
                    expect(page.locator(escaped_selector)).to_be_visible(timeout=timeout)
                
                # Handle scrolling to bottom
                elif action == 'scroll_to_bottom':
                    print(f"‚¨áÔ∏è Scrolling to bottom of page")
                    page.evaluate("window.scrollTo(0, document.body.scrollHeight)")
                    print(f"‚úÖ Scrolled to bottom of page")
                
                # Handle element clicking
                elif action == 'click':
                    selector = step['selector']
                    escaped_selector = selector.replace('"', '\\"').replace("'", "\\'")
                    print(f"üëÜ Clicking selector: {selector}")
                    locator = page.locator(escaped_selector)
                    
                    # Wait for element to be visible with retry logic
                    try:
                        expect(locator).to_be_visible(timeout=5000)
                        locator.click()
                        print(f"‚úÖ Clicked selector: {selector}")
                    except Exception as e:
                        print(f"‚ö†Ô∏è Selector '{selector}' not found or not clickable: {e}")
                        
                        # Try force click if pointer events are intercepted
                        if "intercepts pointer events" in str(e):
                            try:
                                print(f"üîß Trying force click for selector: {selector}")
                                locator.click(force=True, timeout=5000)
                                print(f"‚úÖ Force clicked selector: {selector}")
                                continue  # Skip alternative selectors if force click succeeds
                            except Exception as force_e:
                                print(f"‚ö†Ô∏è Force click also failed: {force_e}")
                                # Try clicking with JavaScript as last resort
                                try:
                                    print(f"üîß Trying JavaScript click for selector: {selector}")
                                    page.evaluate(f"document.querySelector('{escaped_selector}').click()")
                                    print(f"‚úÖ JavaScript clicked selector: {selector}")
                                    continue  # Skip alternative selectors if JS click succeeds
                                except Exception as js_e:
                                    print(f"‚ö†Ô∏è JavaScript click also failed: {js_e}")
                                    # Continue to alternative selectors
                        
                        # Try alternative selectors if available
                        alt_selectors = step.get('alt_selectors', [])
                        for alt_selector in alt_selectors:
                            try:
                                alt_escaped = alt_selector.replace('"', '\\"').replace("'", "\\'")
                                alt_locator = page.locator(alt_escaped)
                                expect(alt_locator).to_be_visible(timeout=3000)
                                alt_locator.click()
                                print(f"‚úÖ Clicked alternative selector: {alt_selector}")
                                break
                            except Exception as alt_e:
                                print(f"‚ö†Ô∏è Alternative selector '{alt_selector}' also failed: {alt_e}")
                                continue
                        else:
                            # If no alternative worked, raise the original error
                            raise e
                    
                    if step.get('wait_for_navigation', False):
                        page.wait_for_load_state("networkidle", timeout=30000)
                
                # Handle waiting for navigation
                elif action == 'wait_for_navigation':
                    print("‚è≥ Waiting for navigation...")
                    page.wait_for_load_state("networkidle")
                
                # Handle form filling
                elif action in ['fill', 'fill_form']:
                    selector = step['selector']
                    value = step['value']
                    escaped_selector = selector.replace('"', '\\"').replace("'", "\\'")
                    escaped_value = value.replace('"', '\\"').replace("'", "\\'")
                    print(f"üìù Filling form: {selector} = {value}")
                    locator = page.locator(escaped_selector)
                    expect(locator).to_be_visible(timeout=10000)
                    locator.fill(escaped_value)
                
                # Handle keyboard press
                elif action == 'keyboard_press':
                    key = step.get('selector', '') or step.get('key', 'Enter')
                    print(f"‚å®Ô∏è Pressing key: {key}")
                    page.keyboard.press(key)
                
                # Handle content extraction
                elif action == 'extract_content':
                    selectors = step.get('selectors', ["h1", "h2", "h3", "p"])
                    print(f"üìÑ Extracting content from selectors: {selectors}")
                    content = {}
                    for selector_config in selectors:
                        if isinstance(selector_config, dict):
                            selector = selector_config.get('selector', '')
                            label = selector_config.get('label') or selector
                            fields = selector_config.get('fields') or ['text']
                            attributes = selector_config.get('attributes') or []
                        else:
                            selector = selector_config
                            label = selector
                            fields = ['text']
                            attributes = []

                        if not selector:
                            print("‚ö†Ô∏è Empty selector encountered in extract_content step, skipping")
                            continue

                        escaped_selector = selector.replace('"', '\\"').replace("'", "\\'")
                        elements = page.query_selector_all(escaped_selector)
                        if not elements:
                            print(f"‚ö†Ô∏è No elements found for selector: {selector}")

                        entry_data = {}
                        normalized_fields = [field.lower() for field in fields]

                        if 'text' in normalized_fields:
                            entry_data['text'] = [
                                (element.text_content() or '').strip()
                                for element in elements
                                if element and (element.text_content() or '').strip()
                            ]

                        if 'html' in normalized_fields:
                            entry_data['html'] = [
                                element.inner_html()
                                for element in elements
                                if element
                            ]

                        if 'value' in normalized_fields:
                            entry_data['value'] = [
                                element.get_attribute('value')
                                for element in elements
                                if element
                            ]

                        attribute_values = {}
                        for attribute_name in attributes:
                            attribute_values[attribute_name] = [
                                element.get_attribute(attribute_name) if element else None
                                for element in elements
                            ]

                        if attribute_values:
                            entry_data['attributes'] = attribute_values

                        if not entry_data:
                            entry_data['text'] = [
                                (element.text_content() or '').strip()
                                for element in elements
                                if element and (element.text_content() or '').strip()
                            ]

                        if len(entry_data) == 1 and 'text' in entry_data:
                            content[label] = entry_data['text']
                        else:
                            content[label] = entry_data

                    print("Extracted content:", json.dumps(content, indent=2))
                    _append_content_to_file(content)
        else:
            print("‚ÑπÔ∏è No automation flow defined, basic test completed")
    except Exception as e:
        try:
            from src.core.screenshot_manager import capture_page_screenshot
            _p,_b = capture_page_screenshot(page, prefix="error")
        except Exception as primary_exc:
            try:
                page.screenshot(path="error.png")  # fallback legacy
            except Exception as legacy_exc:
                print(f"Screenshot capture failed (legacy fallback also failed): {legacy_exc}; primary: {primary_exc}")
        raise e
